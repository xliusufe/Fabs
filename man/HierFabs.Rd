% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/HierFabs.r
\name{HierFabs}
\alias{HierFabs}
\title{A hierarchical Forward and Backward Stagewise (HierFabs) algorithm for identifying hierachical interaction of genomics data.}
\usage{
HierFabs(
  G,
  y,
  E,
  weight = NULL,
  model = c("gaussian", "cox", "quantile", "logistic"),
  back = TRUE,
  stoping = TRUE,
  eps = 0.01,
  xi = 10^-6,
  iter = 3000,
  lambda.min = NULL,
  lambda.ratio = NULL,
  hier = c("strong", "weak"),
  max_s = NULL,
  diagonal = FALSE,
  status = NULL,
  gamma = NULL,
  tau = NULL,
  criteria = c("EBIC", "BIC")
)
}
\arguments{
\item{G}{Gene matrix, each row is an observation vector.}

\item{y}{Response variable. For logistic regression model, y takes value at 1 and -1.}

\item{E}{An optional environment matrix. If Z is given, the interactions between environment and gene are of interest. Otherwise, the gene-gene interactions are of interest.}

\item{weight}{An optional weights. Default is 1 for each observation.}

\item{model}{A character string representing one of the built-in models. 'gaussian' for linear model and 'cox' for cox model.}

\item{back}{An indicator of whether to take backward steps.}

\item{stoping}{An indicator of whether to stop iteration when lambda is less than lambda.min.}

\item{eps}{Step size. Default is 0.01.}

\item{xi}{A tolerate to improve program stability. Default is 10^-6.}

\item{iter}{Maximum number of outer-loop iterations allowed. Default is 3000.}

\item{lambda.min}{Smallest value for lambda. \code{NULL} by default.}

\item{lambda.ratio}{Smallest value for lambda, as a fraction of lambda.max. Works when lambda.min is \code{NULL}.}

\item{hier}{Whether to enforce strong or weak heredity. Default is 'strong'.}

\item{max_s}{Limit the maximum number of variables in the model. When exceed this limit, program will early stopped.}

\item{diagonal}{An indicator of whether to include "pure" quadratic terms. Work when gene-gene interactions are of interest.}

\item{status}{A censoring indicator.}

\item{gamma}{A tuning parameter in EBIC.}

\item{tau}{parameter for quantile regression.}

\item{criteria}{The criteria used to select the optimal solution.}
}
\value{
A list.
\itemize{
  \item theta - The coefficients of covariates, each column is a solution.
  \item beta - The optimal solution.
  \item lambda - Lambda sequence.
  \item direction - Update indicator. 1 means take a forward step, -1 means take a backward step.
  \item iter - Number of iterations.
  \item EBIC - EBIC for each solution.
  \item loss - loss for each solution.
  \item df - Number of nonzero coefficients.
  \item opt - Position of the optimal tuning based on EBIC.
  \item intercept - The intercept term, which appearance is due to standardization.
}
}
\description{
A hierarchical Forward and Backward Stagewise (HierFabs) algorithm for identifying hierachical interaction of genomics data.
}
\examples{
set.seed(0)
n = 500
p = 100
x = matrix(rnorm(n*p),n,p)
eta = x[,1:4] \%*\% rep(1,4) + 3*x[,1]*x[,2] + 3*x[,1]*x[,4]
y =  eta + rnorm(n)
xtest = matrix(rnorm(n*p),n,p)
eta.test = xtest[,1:4] \%*\% rep(1,4) + 3*xtest[,1]*xtest[,2] + 3*xtest[,1]*xtest[,4]
ytest =  eta.test + rnorm(n)
fit.gg.strong = HierFabs(x, y)
y.pred.gg.s = predict(fit.gg.strong, xtest, ytest)
y.pred.gg.s$mse
print(fit.gg.strong)

## Weak hierarchy
fit.gg.weak = HierFabs(x, y, hier="weak")
y.pred.gg.w = predict(fit.gg.weak, xtest, ytest)
y.pred.gg.w$mse
print(fit.gg.weak)

## Cox model with Gene-Environment interactions
pz = 10
z = matrix(rnorm(n*pz),n,pz)
eta.ge = x[,1:4] \%*\% rep(1,4) + z[,1] + z[,2] + 3*x[,1]*z[,1] + 3*x[,2]*z[,2]
err = log(rweibull(n, shape = 1, scale = 1))
y0 = exp(-eta.ge + err)
cens = quantile(y0, 0.9)
y.ge = pmin(y0, cens)
status = 1 * (y0<=cens)
ztest = matrix(rnorm(n*pz),n,pz)
eta.ge.test = rowSums(xtest[,1:4]) + ztest[,1] + ztest[,2]
eta.ge.test = eta.ge.test + 3*xtest[,1]*ztest[,1] + 3*xtest[,2]*ztest[,2]
err.test = log(rweibull(n, shape = 1, scale = 1))
y0.test = exp(-eta.ge.test + err.test)
cens = quantile(y0.test, 0.9)
y.ge.test = pmin(y0.test, cens)
status.test = 1 * (y0.test<=cens)
fit.ge.strong = HierFabs(x, y.ge, z, model="cox", status=status)
y.pred.ge.s = predict(fit.ge.strong, xtest, y.ge.test, ztest, status.test)
y.pred.ge.s$c.index
print(fit.ge.strong)

## Weak hierarchy
fit.ge.weak = HierFabs(x, y.ge, z, model="cox", status=status, hier="weak")
y.pred.ge.w = predict(fit.ge.weak, xtest, y.ge.test, ztest, status.test)
y.pred.ge.w$c.index
print(fit.ge.weak)
}
\seealso{
\code{\link{predict.HierFabs}}, \code{\link{print.HierFabs}}
}
